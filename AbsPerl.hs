

module AbsPerl where
import LexPerl

-- Haskell module generated by the BNF converter

data Type 
    = T_Int 
    | T_Float
    | T_Char 
    | T_String 
    | T_Void 
    | T_Bool 
    | T_Error 
    | Pointer Type 
    | ArrDef Type Integer 
    deriving (Eq, Ord, Show)

newtype Ident = Ident String deriving (Eq, Ord, Show )
data Boolean = Boolean_True Int| Boolean_False Int
  deriving (Eq, Ord, Show)

data Program = Prog [Decl]
  deriving (Eq, Ord, Show )

data Decl
    = Dvar Type Int [VarDeclInit] 
    | UndVar Type Int [UndVarDecl]
    | Dfun Type Ident Int [Parameter] [StmtDecl]
  deriving (Eq, Ord, Show )

data UndVarDecl = UndVarD UndArr | UndVarA UndVar
  deriving (Eq, Ord, Show )

data UndArr = UndA Ident Int
  deriving (Eq, Ord, Show )

data UndVar = UndV Ident Int
  deriving (Eq, Ord, Show )

data VarDeclInit
    = VarDeclInA VarDeclInitArray | VarDeclInV VarDeclInitVar
  deriving (Eq, Ord, Show )

data VarDeclInitArray = VarDeclInitAr Ident Array Int
  deriving (Eq, Ord, Show )

data VarDeclInitVar = VarDeclInitV Ident RExpr Int
  deriving (Eq, Ord, Show )

data Array = Arr [Array] Int| ArrE [RExpr]
  deriving (Eq, Ord, Show )

data Parameter = Param Modality Type Ident
  deriving (Eq, Ord, Show )

data Modality
    = M_Void
    | M_Val Int
    | M_Ref Int
    | M_Const Int
    | M_Res Int
    | M_Valres Int
    | M_Name Int
  deriving (Eq, Ord, Show)

data StmtDecl = Decls Decl | Stmts Stmt 
  deriving (Eq, Ord, Show)

data Stmt
    = ProcCall FunCall Int
    | BlockDecl Int [StmtDecl] 
    | Jmp JumpStmt 
    | Iter IterStmt 
    | Sel SelectionStmt 
    | Assgn LExpr Assignment_op RExpr Int
    | LExprStmt LExpr Int
    | TryC TryCatch 
  deriving (Eq, Ord, Show)

data Assignment_op
    = Assign Int
    | AssgnMul Int
    | AssgnAdd Int
    | AssgnDiv Int
    | AssgnSub Int
    | AssgnPow Int
    | AssgnAnd Int
    | AssgnOr Int
  deriving (Eq, Ord, Show )

data TryCatch = Try Int[StmtDecl]  Type String Int[StmtDecl] -- typechecker verifica sia T_Err
  deriving (Eq, Ord, Show)

data JumpStmt = RetExpVoid Int| RetExp RExpr Int
  deriving (Eq, Ord, Show )

data SelectionStmt
    = IfNoElse RExpr Int[StmtDecl]
    | IfElsIf RExpr Int[StmtDecl] Elsif
  deriving (Eq, Ord, Show )

data Elsif 
    = ElsIf RExpr Int[StmtDecl] Elsif 
    | EndElsIf Int[StmtDecl]
  deriving (Eq, Ord, Show )

data IterStmt
    = While RExpr Int [IterStmtDecl]
    | DoWhile [IterStmtDecl] RExpr Int
    | DoUntil [IterStmtDecl] RExpr Int
    | For ForStmtDecl RExpr ForStmt Int [IterStmtDecl]
    | ForEach ForStmt ForStmt Int[ IterStmtDecl]
  deriving (Eq, Ord, Show )

data IterStmtDecl = Break Int| Continue Int | ItStDe StmtDecl 
   deriving (Eq, Ord, Show)

data ForStmtDecl 
    = ForDeclInit Type Ident Assignment_op RExpr Int
    | Simple Ident Assignment_op RExpr Int
  deriving (Eq, Ord, Show)

data ForStmt 
    = LexprForStmt LExpr 
    | ForDecl Type Ident Int
    | AssFor Ident Assignment_op RExpr 
  deriving (Eq, Ord, Show)


data RExpr
    = Rexpr RExpr Int
    | InfixOp InfixOp RExpr RExpr Int
    | UnaryOp UnaryOp RExpr Int
    | Ref LExpr Int
    | FCall FunCall 
    | Int Integer
    | Char Char
    | String String
    | Float Double
    | Bool Boolean
    | Lexpr LExpr
  deriving (Eq, Ord, Show)

data InfixOp = ArithOp ArithOp | RelOp RelOp | BoolOp BoolOp 
  deriving (Eq,Ord,Show)

data ArithOp = Add | Sub | Mul | Div | Mod | Pow 
  deriving (Eq,Ord,Show)

data BoolOp = And | Or 
  deriving (Eq,Ord,Show)

data RelOp = Eq | Neq | Lt | LtE | Gt | GtE 
  deriving (Eq,Ord,Show)

data UnaryOp = Not | Neg 
  deriving (Eq,Ord,Show)

data FunCall = Call Ident [RExpr] Int
  deriving (Eq, Ord, Show)

data LExpr
    = Lex LExpr Int
    | Deref LExpr Int
    | PrePostIncDecr PrePost IncDecr LExpr Int
    | BasLExpr BLExpr 
  deriving (Eq, Ord, Show)

data PrePost = Post | Pre 
  deriving (Eq,Ord,Show)

data IncDecr = Inc | Decr 
  deriving (Eq,Ord,Show)

data BLExpr = ArrayEl BLExpr RExpr Int| Id Ident Int
  deriving (Eq, Ord, Show )