{-# OPTIONS_GHC -fno-warn-incomplete-patterns #-}
module PrintPerl where

-- pretty-printer generated by the BNF converter

import AbsPerl
import LexPerl
import ErrM
import Data.Char


-- the top-level printing method
printTree :: Print a => a -> String
printTree = render . prt 0

type Doc = [ShowS] -> [ShowS]

doc :: ShowS -> Doc
doc = (:)

render :: Doc -> String
render d = rend 0 (map ($ "") $ d []) "" where
  rend i ss = case ss of
    "["       :ts -> showChar '[' . rend i ts
    "("       :ts -> showChar '(' . rend i ts
    "{" : "}" :ts -> showChar '{' . new  (i) . showChar '}' . new  (i - 1) . rend (i - 1) ts
    "{"       :ts -> showChar '{' . new  (i + 1) . rend (i+1) ts
    ";" : "}" :ts -> showChar ';' . new  (i - 1) . showChar '}' . new  (i - 2) . rend (i - 2) ts
    ";"       :ts -> showChar ';' . new  i       . rend i     ts
    "}" : ";" :ts -> new (i - 1)  . space    "}" . showChar ';' . new  (i - 1) . rend (i - 1) ts
    "}"       :ts -> new (i - 1)  . showChar '}' . new (i - 1)  . rend (i - 1) ts
    t  : ","  :ts -> showString t . space    "," . rend i ts
    t  : ")"  :ts -> showString t . showChar ')' . rend i ts
    t  : "]"  :ts -> showString t . showChar ']' . rend i ts
    t         :ts -> space t . rend i ts
    _             -> id
  new i   = showChar '\n' . replicateS (2*i) (showChar ' ') . dropWhile isSpace
  space t = showString t . (\s -> if null s then "" else ' ':s)

--
parenth :: Doc -> Doc
parenth ss = doc (showChar '(') . ss . doc (showChar ')')
--
concatS :: [ShowS] -> ShowS
concatS = foldr (.) id
--
concatD :: [Doc] -> Doc
concatD = foldr (.) id

replicateS :: Int -> ShowS -> ShowS
replicateS n f = concatS (replicate n f)

-- the printer class does the job
class Print a where
  prt :: Int -> a -> Doc
  prtList :: Int -> [a] -> Doc
  prtList i = concatD . map (prt i)

instance Print a => Print [a] where
  prt = prtList

instance Print Char where
  prt _ s = doc (showChar '\'' . mkEsc '\'' s . showChar '\'')
  prtList _ s = doc (showChar '"' . concatS (map (mkEsc '"') s) . showChar '"')

mkEsc :: Char -> Char -> ShowS
mkEsc q s = case s of
  _ | s == q -> showChar '\\' . showChar s
  '\\'-> showString "\\\\"
  '\n' -> showString "\\n"
  '\t' -> showString "\\t"
  _ -> showChar s

prPrec :: Int -> Int -> Doc -> Doc
prPrec i j = if j < i then parenth else id


instance Print Integer where
  prt _ x = doc (shows x)


instance Print Double where
  prt _ x = doc (shows x)


instance Print Ident where
  prt _ (Ident i) = doc (showString (i))

instance Print Boolean where
  prt i e = case e of
    Boolean_True  _ -> prPrec i 0 (concatD [doc (showString "True" )])
    Boolean_False _ -> prPrec i 0 (concatD [doc (showString "False")])

instance Print RExpr where
  prt i e = case e of
    InfixOp (BoolOp  Or )   rexpr1 rexpr2 _ -> prPrec i 0  (concatD [prt 0  rexpr1, doc (showString "||"), prt 1  rexpr2])
    InfixOp (BoolOp  And)   rexpr1 rexpr2 _ -> prPrec i 1  (concatD [prt 1  rexpr1, doc (showString "&&"), prt 2  rexpr2])
    UnaryOp Not             rexpr  _        -> prPrec i 2  (concatD [doc                (showString "!" ), prt 3  rexpr ])
    InfixOp (RelOp   Eq )   rexpr1 rexpr2 _ -> prPrec i 5  (concatD [prt 6  rexpr1, doc (showString "=="), prt 6  rexpr2])
    InfixOp (RelOp   Neq)   rexpr1 rexpr2 _ -> prPrec i 5  (concatD [prt 6  rexpr1, doc (showString "!="), prt 6  rexpr2])
    InfixOp (RelOp   Lt )   rexpr1 rexpr2 _ -> prPrec i 5  (concatD [prt 6  rexpr1, doc (showString "<" ), prt 6  rexpr2])
    InfixOp (RelOp   LtE)   rexpr1 rexpr2 _ -> prPrec i 5  (concatD [prt 6  rexpr1, doc (showString "<="), prt 6  rexpr2])
    InfixOp (RelOp   Gt )   rexpr1 rexpr2 _ -> prPrec i 5  (concatD [prt 6  rexpr1, doc (showString ">" ), prt 6  rexpr2])
    InfixOp (RelOp   GtE)   rexpr1 rexpr2 _ -> prPrec i 5  (concatD [prt 6  rexpr1, doc (showString ">="), prt 6  rexpr2])
    InfixOp (ArithOp Add)   rexpr1 rexpr2 _ -> prPrec i 7  (concatD [prt 7  rexpr1, doc (showString "+" ), prt 8  rexpr2])
    InfixOp (ArithOp Sub)   rexpr1 rexpr2 _ -> prPrec i 7  (concatD [prt 7  rexpr1, doc (showString "-" ), prt 8  rexpr2])
    InfixOp (ArithOp Mul)   rexpr1 rexpr2 _ -> prPrec i 8  (concatD [prt 8  rexpr1, doc (showString "*" ), prt 9  rexpr2])
    InfixOp (ArithOp Div)   rexpr1 rexpr2 _ -> prPrec i 8  (concatD [prt 8  rexpr1, doc (showString "/" ), prt 9  rexpr2])
    InfixOp (ArithOp Mod)   rexpr1 rexpr2 _ -> prPrec i 8  (concatD [prt 8  rexpr1, doc (showString "%" ), prt 9  rexpr2])
    InfixOp (ArithOp Pow)   rexpr1 rexpr2 _ -> prPrec i 9  (concatD [prt 10 rexpr1, doc (showString "**"), prt 9  rexpr2])
    UnaryOp Neg             rexpr  _        -> prPrec i 11 (concatD [doc                (showString "-" ), prt 12 rexpr ])
    Ref                     lexpr  _        -> prPrec i 11 (concatD [doc                (showString "\\"), prt 0  lexpr ])
    FCall                   funcall         -> prPrec i 12 (concatD [prt 0 funcall])
    Const                   cons            -> prPrec i 13 (concatD [prt 0 cons])
    Lexpr                   lexpr           -> prPrec i 14 (concatD [prt 0 lexpr  ])
    Rexpr                   rexpr  _        -> prPrec i 15 (concatD [doc (showString "("), prt 0 rexpr, doc (showString ")")])
  prtList _ []      = (concatD [])
  prtList _ [x]     = (concatD [prt 0 x])
  prtList _ (x:xs)  = (concatD [prt 0 x, doc (showString ","), prt 0 xs])

instance Print Const where
  prt i e = case e of
    Int                     n               -> prPrec i 0 (concatD [prt 0 n      ])
    Char                    c               -> prPrec i 0 (concatD [prt 0 c      ])
    String                  str             -> prPrec i 0 (concatD [prt 0 str    ])
    Float                   d               -> prPrec i 0 (concatD [prt 0 d      ])
    Bool                    boolean         -> prPrec i 0 (concatD [prt 0 boolean])

instance Print FunCall where
  prt i e = case e of
    Call   id rexprs _        -> prPrec i 0  (concatD [prt 0 id, doc (showString "("), prt 0 rexprs, doc (showString ")")])

instance Print LExpr where
  prt i e = case e of
    Lex                       lexpr _ -> prPrec i 0 (concatD [doc (showString "("),  prt 0 lexpr, doc (showString ")")])
    Deref                     rexpr _ -> prPrec i 0 (concatD [doc (showString "$"),  prt 0 rexpr])
    PrePostIncDecr Post Inc   lexpr _ -> prPrec i 0 (concatD [prt 1 lexpr,           doc (showString "++")])
    PrePostIncDecr Post Decr  lexpr _ -> prPrec i 0 (concatD [prt 1 lexpr,           doc (showString "--")])
    PrePostIncDecr Pre Inc    lexpr _ -> prPrec i 1 (concatD [doc (showString "++"), prt 2 lexpr])
    PrePostIncDecr Pre Decr   lexpr _ -> prPrec i 1 (concatD [doc (showString "--"), prt 2 lexpr])
    BasLExpr                  blexpr  -> prPrec i 2 (concatD [prt 0 blexpr])

instance Print BLExpr where
  prt i e = case e of
    ArrayEl   blexpr rexpr  _ -> prPrec i 0 (concatD [prt 0 blexpr, doc (showString "["), prt 0 rexpr, doc (showString "]")])
    Id        id   doa        -> prPrec i 0 (concatD [prt 0 doa, prt 0 id])

instance Print DolOrAt where
  prt i e = case e of
       Dollar  -> prPrec i 0 (concatD [doc (showString "$")])
       At      -> prPrec i 0 (concatD [doc (showString "@")])

instance Print Program where
  prt i e = case e of
    Prog decls                -> prPrec i 0 (concatD [prt 0 decls])

instance Print Decl where
  prt i e = case e of
    Dvar    typ _  vardeclinits -> prPrec i 0 (concatD [doc (showString "my"), prt 0 typ, prt 0 vardeclinits, doc (showString ";")])
    UndVar  typ _  undvardecls  -> prPrec i 0 (concatD [doc (showString "my"), prt 0 typ, prt 0 undvardecls, doc (showString ";")])
    Dfun    typ id _ parameters stmtdecls -> prPrec i 0 (concatD [doc (showString "sub"), prt 0 typ, prt 0 id, doc (showString "("), prt 0 parameters, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}")])
  prtList _ []     = (concatD [])
  prtList _ (x:xs) = (concatD [prt 0 x, prt 0 xs])

instance Print UndVarDecl where
  prt i e = case e of
    UndVarD undarr -> prPrec i 0 (concatD [prt 0 undarr])
    UndVarA undvar -> prPrec i 0 (concatD [prt 0 undvar])
  prtList _ [x]    = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])

instance Print UndArr where
  prt i e = case e of
    UndA id _ -> prPrec i 0 (concatD [ doc (showString "@"), prt 0 id])

instance Print UndVar where
  prt i e = case e of
    UndV id _ -> prPrec i 0 (concatD [ doc (showString "$"), prt 0 id])

instance Print Type where
  prt i e = case e of
    T_Bool  -> prPrec i 0 (concatD [doc (showString "bool")])
    T_Char  -> prPrec i 0 (concatD [doc (showString "char")])
    T_Float  -> prPrec i 0 (concatD [doc (showString "float")])
    T_Int  -> prPrec i 0 (concatD [doc (showString "int")])
    T_Void  -> prPrec i 0 (concatD [doc (showString "void")])
    T_String  -> prPrec i 0 (concatD [doc (showString "string")])
    T_Error  -> prPrec i 0 (concatD [doc (showString "Exception")])
    ArrDef typ n  -> prPrec i 0 (concatD [prt 0 typ, doc (showString "["), prt 0 n, doc (showString "]")])
    Pointer lexpr  -> prPrec i 0 (concatD [doc (showString "\\"), prt 0 lexpr])

instance Print VarDeclInit where
  prt i e = case e of
    VarDeclInA vardeclinitarray -> prPrec i 0 (concatD [prt 0 vardeclinitarray])
    VarDeclInV vardeclinitvar -> prPrec i 0 (concatD [prt 0 vardeclinitvar])
  prtList _ [x] = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])
instance Print VarDeclInitArray where
  prt i e = case e of
    VarDeclInitAr id array _-> prPrec i 0 (concatD [doc (showString "@"), prt 0 id, doc (showString "="), doc (showString "("), prt 0 array, doc (showString ")")])

instance Print VarDeclInitVar where
  prt i e = case e of
    VarDeclInitV id rexpr _ -> prPrec i 0 (concatD [doc (showString "$"), prt 0 id, doc (showString "="), prt 0 rexpr])

instance Print Array where
  prt i e = case e of
    Arr arrays _ -> prPrec i 0 (concatD [doc (showString "("), prt 0 arrays, doc (showString ")")])
    ArrE rexpr -> prPrec i 0 (concatD [prt 0 rexpr])
  prtList _ [] = (concatD [])
  prtList _ [x] = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])
instance Print Parameter where
  prt i e = case e of
    Param modality typ doa id -> prPrec i 0 (concatD [prt 0 modality, prt 0 typ, prt 0 doa, prt 0 id])
  prtList _ [] = (concatD [])
  prtList _ [x] = (concatD [prt 0 x])
  prtList _ (x:xs) = (concatD [prt 0 x, doc (showString ","), prt 0 xs])
instance Print Modality where
  prt i e = case e of
    M_Void -> prPrec i 0 (concatD [])
    M_Val _ -> prPrec i 0 (concatD [doc (showString "val")])
    M_Ref _ -> prPrec i 0 (concatD [doc (showString "ref")])
    M_Const _ -> prPrec i 0 (concatD [doc (showString "const")])
    M_Res _ -> prPrec i 0 (concatD [doc (showString "res")])
    M_Valres _ -> prPrec i 0 (concatD [doc (showString "valres")])
    M_Name _ -> prPrec i 0 (concatD [doc (showString "name")])

instance Print StmtDecl where
  prt i e = case e of
    Decls decl -> prPrec i 0 (concatD [prt 0 decl])
    Stmts stmt -> prPrec i 0 (concatD [prt 0 stmt])
  prtList _ [] = (concatD [])
  prtList _ (x:xs) = (concatD [prt 0 x, prt 0 xs])
instance Print Stmt where
  prt i e = case e of
    ProcCall    funcall _     -> prPrec i 0 (concatD [prt 0 funcall, doc (showString ";")])
    BlockDecl   _ stmtdecls   -> prPrec i 0 (concatD [doc (showString "{"), prt 0 stmtdecls, doc (showString "}")])
    Jmp         jumpstmt      -> prPrec i 0 (concatD [prt 0 jumpstmt, doc (showString ";")])
    Iter        iterstmt      -> prPrec i 0 (concatD [prt 0 iterstmt])
    Sel         selectionstmt -> prPrec i 0 (concatD [prt 0 selectionstmt])
    TryC        trycatch      -> prPrec i 0 (concatD [prt 0 trycatch])
    Assgn       lexpr ass_op rexpr _ -> prPrec i 0 (concatD [prt 0 lexpr, prt 0 ass_op, prt 0 rexpr, doc (showString ";")])
    LExprStmt   lexpr _       -> prPrec i 0 (concatD [prt 0 lexpr, doc (showString ";")])
  prtList _ [] = (concatD [])
  prtList _ (x:xs) = (concatD [prt 0 x, prt 0 xs])

instance Print Int where
  prt _ x = doc (shows x)

instance Print TryCatch where
  prt i e = case e of
    Try _ stmtdecls1 typespec str _ stmtdecls2 -> prPrec i 0 (concatD [doc (showString "try"), doc (showString "{"), prt 0 stmtdecls1, doc (showString "}"), doc (showString "catch"), doc (showString "("), prt 0 typespec, doc (showString "Exception"), prt 0 str, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls2, doc (showString "}")])

instance Print Assignment_op where
  prt i e = case e of
    Assign _ -> prPrec i 0 (concatD [doc (showString "=")])
    AssgnMul _ -> prPrec i 0 (concatD [doc (showString "*=")])
    AssgnAdd _ -> prPrec i 0 (concatD [doc (showString "+=")])
    AssgnDiv _ -> prPrec i 0 (concatD [doc (showString "/=")])
    AssgnSub _ -> prPrec i 0 (concatD [doc (showString "-=")])
    AssgnPow _ -> prPrec i 0 (concatD [doc (showString "**=")])
    AssgnAnd _ -> prPrec i 0 (concatD [doc (showString "&=")])
    AssgnOr _ -> prPrec i 0 (concatD [doc (showString "|=")])

instance Print JumpStmt where
  prt i e = case e of
    RetExpVoid _ -> prPrec i 0 (concatD [doc (showString "return")])
    RetExp rexpr _ -> prPrec i 0 (concatD [doc (showString "return"), doc (showString "("), prt 0 rexpr, doc (showString ")")])

instance Print IterStmtDecl where
  prt i e = case e of
      ItStDe stmtdecl -> prPrec i 0 (concatD [prt 0 stmtdecl])
      Break _ -> prPrec i 0 (concatD [doc (showString "break")])
      Continue _ -> prPrec i 0 (concatD [doc (showString "continue")])

instance Print SelectionStmt where
  prt i e = case e of
    IfNoElse rexpr _ stmtdecls -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 rexpr, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}")])
    IfElsIf rexpr _ stmtdecls elsif -> prPrec i 0 (concatD [doc (showString "if"), doc (showString "("), prt 0 rexpr, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}"), prt 0 elsif])

instance Print Elsif where
  prt i e = case e of
    ElsIf  rexpr _ stmtdecls elsif -> prPrec i 0 (concatD [doc (showString "elsif"), doc (showString "("), prt 0 rexpr, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}"), prt 0 elsif])
    EndElsIf _ stmtdecls -> prPrec i 0 (concatD [doc (showString "else"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}")])

instance Print IterStmt where
  prt i e = case e of
    While rexpr _ stmtdecls -> prPrec i 0 (concatD [doc (showString "while"), doc (showString "("), prt 0 rexpr, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}")])
    DoWhile stmtdecls rexpr _ -> prPrec i 0 (concatD [doc (showString "do"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}"), doc (showString "while"), doc (showString "("), prt 0 rexpr, doc (showString ")"), doc (showString ";")])
    DoUntil stmtdecls rexpr _ -> prPrec i 0 (concatD [doc (showString "do"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}"), doc (showString "until"), doc (showString "("), prt 0 rexpr, doc (showString ")"), doc (showString ";")])
    For stmtdecl rexpr stmt _ stmtdecls -> prPrec i 0 (concatD [doc (showString "for"), doc (showString "("), prt 0 stmtdecl, doc (showString ";"), prt 0 rexpr, doc (showString ";"), prt 0 stmt, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}")])
    ForEach stmtdecl stmt _ stmtdecls -> prPrec i 0 (concatD [doc (showString "foreach"), prt 0 stmtdecl, doc (showString "("), prt 0 stmt, doc (showString ")"), doc (showString "{"), prt 0 stmtdecls, doc (showString "}")])

instance Print ForStmtDecl where
  prt i e  = case e of 
    ForDeclInit typ id ass rexpr _ -> prPrec i 0 (concatD [prt 0 typ, prt 0 id, prt 0 ass, prt 0 rexpr])
    Simple id ass rexpr _ -> prPrec i 0 (concatD [prt 0 id, prt 0 ass, prt 0 rexpr])

instance Print ForStmt where
  prt i e = case e of
    LexprForStmt  lexpr -> prPrec i 0 (concatD [prt 0 lexpr])
    ForDecl typ id _ -> prPrec i 0 (concatD [prt 0 typ, prt 0 id])
    AssFor id ass rexpr -> prPrec i 0 (concatD [prt 0 id, prt 0 ass, prt 0 rexpr])
